<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>MRSA Therapy Evidence Map</title>
    <style type="text/css">
        .custom-button-container {
            display: inline-block;
        }

        .custom-button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }

        .custom-button:hover {
            background-color: #0056b3;
        }

        .hidden {
            display: none;
        }

        .Title {
            color: gray;
            height: 20px;
            font-size: 20px;
            font-family: Helvetica;
        }

        .Textbox {
            font-size: 15px;
            font-family: Helvetica;
            padding: 5px;
            text-align: left;
            float: left;
            height: 20px;
            border-radius: 15px;
        }
    </style>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
</head>

<body>
    <script type="text/javascript">
        // evidence map version 0.053
        // TODO
        ////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////
        console.log("initiating variables");

        //  INITIAL VARIABLES:
        var svgNS = "http://www.w3.org/2000/svg";  // initiates the namespace


        // these two variable store the data:-
        var dataset = []
        var dataset_links = []

var dataset = [
  {
    "\ufeff": "0",
    "title": "G0",
    "size": 1,
    "group": 0,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "10.1016/j.jcf.2018.07.005",
    "recommend": "Background: The prevalence of methicillin-resistant Staphylococcus aureus (MRSA) in individuals with cystic fibrosis (CF) has increased significantly. While studies demonstrate that persistent MRSA infection in CF is associated with poor clinical outcomes, there are no randomized controlled studies informing management.\nMethods: The Persistent MRSA Eradication Protocol was a double-blind, randomized, placebo-controlled study investigating a comprehensive 28-day treatment regimen with or without inhaled vancomycin for eradication of MRSA. Eligible participants had CF and documented persistent MRSA infection. All participants received oral antibiotics, topical decontamination, and environmental cleaning and were randomized to receive inhaled vancomycin or inhaled placebo. The primary outcome was the difference in MRSA eradication rates one month after completion of the treatment protocol.\nResults: 29 participants were randomized. Four subjects in the inhaled vancomycin group required withdrawal from the study for bronchospasm before outcome data were collected and were excluded from analysis. There was no difference in the primary outcome: 2/10 (20%) of subjects in the intervention group and 3/15 (20%) in the placebo group had a MRSA negative sputum culture one month after treatment. There were no statistically significant differences in the rates of MRSA eradication at the end of treatment or three months after treatment completion.\nConclusions: This study suggests that persistent MRSA infection is difficult to eradicate, even with multimodal antibiotics. The use of a single course of inhaled vancomycin may not lead to higher rates of MRSA eradication in individuals with CF and may be associated with bronchospasm. FUND: This trial was financially supported by the Cystic Fibrosis Foundation.",
    "full_title": "Eradication of persistent methicillin-resistant Staphylococcus aureus infection in cystic fibrosis (2019) doi: https://dx.doi.org/10.1016/j.jcf.2018.07.005"
  },
  {
    "\ufeff": "1",
    "title": "G1",
    "size": 1,
    "group": 0,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "10.1371/journal.pone.0213497",
    "recommend": "Background: Few studies, based on a limited number of patients using non-uniform therapeutic protocols, have analyzed Methicillin-resistant Staphylococcus aureus (MRSA) eradication.\nMethods: In a randomized multicenter trial conducted on patients with new-onset MRSA infection we evaluated the efficacy of an early eradication treatment (arm A) compared with an observational group (B). Arm A received oral rifampicin and trimethoprim/sulfamethoxazole (21 days). Patients' microbiological status, FEV1, BMI, pulmonary exacerbations and use of antibiotics were assessed.\nResults: Sixty-one patients were randomized. Twenty-nine (47.5%) patients were assigned to active arm A and 32 (52.5%) patients to observational arm B. Twenty-nine (47.5%) patients, 10 patients in arm A and 19 in arm B, dropped out of the study. At 6 months MRSA was eradicated in 12 (63.2%) out of 19 patients in arm A while spontaneous clearance was observed in 5 (38.5%) out of 13 patients in arm B. A per-protocol analysis showed a 24.7% difference in the proportion of MRSA clearance between the two groups (z = 1.37, P(Z>z) = 0.08). Twenty-seven patients, 15 (78.9%) out of 19 in arm A and 12 (92.3%) out of 13 in arm B, were able to perform spirometry. The mean (\u00b1SD) FEV1 change from baseline was 7.13% (\u00b114.92) in arm A and -1.16% (\u00b15.25) in arm B (p = 0.08). In the same period the BMI change (mean \u00b1SD) from baseline was 0.54 (\u00b11.33) kg/m2 in arm A and -0.38 (\u00b11.56) kg/m2 in arm B (p = 0.08). At 6 months no statistically significant differences regarding the number of pulmonary exacerbations, days spent in hospital and use of antibiotics were observed between the two arms.\nConclusions: Although the statistical power of the study is limited, we found a 24.7% higher clearance of MRSA in the active arm than in the observational arm at 6 months. Patients in the active arm A also had favorable FEV1 and BMI tendencies.",
    "full_title": "Methicillin-resistant Staphylococcus aureus eradication in cystic fibrosis patients: a randomized multicenter study (2019) doi: https://dx.doi.org/10.1371/journal.pone.0213497"
  },
  {
    "\ufeff": "2",
    "title": "G2",
    "size": 1,
    "group": 0,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "10.1136/thoraxjnl-2016-208949",
    "recommend": "Objective: To evaluate microbiological effectiveness, that is, culture negativity of a non-blinded eradication protocol (Rx) compared with observation (Obs) in clinically stable cystic fibrosis participants with newly positive methicillin resistant Staphylococcusaureus (MRSA) cultures.\nDesign: This non-blinded trial randomised participants ages 4-45 years with first or early (\u22642 positive cultures within 3 years) MRSA-positive culture without MRSA-active antibiotics within 4 weeks 1:1 to Rx or Obs. The Rx protocol was: oral trimethoprim-sulfamethoxazole or if sulfa-allergic, minocycline plus oral rifampin; chlorhexidine mouthwash for 2 weeks; nasal mupirocin and chlorhexidine body wipes for 5 days and environmental decontamination for 21 days. The primary end point was MRSA culture status at day 28.\nResults: Between 1 April 2011 to September 2014, 45 participants (44% female, mean age 11.5 years) were randomised (24 Rx, 21 Obs). At day 28, 82% (n=18/22) of participants in the Rx arm compared with 26% (n=5/19) in the Obs arm were MRSA-negative. Adjusted for interim monitoring, this difference was 52% (95% CI 23% to 80%, p<0.001). Limiting analyses to participants who were MRSA-positive at the screening visit, 67% (8/12) in the Rx arm and 13% (2/15) in the Obs arm were MRSA-negative at day 28, adjusted difference: 49% (95% CI 22% to 71%, p<0.001). Fifty-four per cent in the Rx arm compared with 10% participants in the Obs arm remained MRSA-negative through day 84. Mild gastrointestinal side effects were higher in the Rx arm.\nConclusions: This MRSA eradication protocol for newly acquired MRSA demonstrated microbiological efficacy with a large treatment effect.",
    "full_title": "Microbiological efficacy of early MRSA treatment in cystic fibrosis in a randomised controlled trial (2017) doi: https://dx.doi.org/10.1136/thoraxjnl-2016-208949"
  },
  {
    "\ufeff": "3",
    "title": "SR0",
    "size": 1,
    "group": 1,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "",
    "recommend": "",
    "full_title": "Eradication of MRSA"
  },
  {
    "\ufeff": "4",
    "title": "SR1",
    "size": 1,
    "group": 1,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "",
    "recommend": "",
    "full_title": "Time to next positive MRSA isolate"
  },
  {
    "\ufeff": "5",
    "title": "SR2",
    "size": 1,
    "group": 1,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "",
    "recommend": "",
    "full_title": "Lung function"
  },
  {
    "\ufeff": "6",
    "title": "SR3",
    "size": 1,
    "group": 1,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "",
    "recommend": "",
    "full_title": "Overall antibiotic use"
  },
  {
    "\ufeff": "7",
    "title": "SR4",
    "size": 1,
    "group": 1,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "",
    "recommend": "",
    "full_title": "Mortality"
  },
  {
    "\ufeff": "8",
    "title": "SR5",
    "size": 1,
    "group": 1,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "",
    "recommend": "",
    "full_title": "Quality of Life"
  },
  {
    "\ufeff": "9",
    "title": "SR6",
    "size": 1,
    "group": 1,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "",
    "recommend": "",
    "full_title": "Isolation of MRSA or other organisms with new antibiotic-resistant phenotypes"
  },
  {
    "\ufeff": "10",
    "title": "SR7",
    "size": 1,
    "group": 1,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "",
    "recommend": "",
    "full_title": "Growth and nutritional status"
  },
  {
    "\ufeff": "11",
    "title": "SR8",
    "size": 1,
    "group": 1,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "",
    "recommend": "",
    "full_title": "Adverse effects of treatment"
  },
  {
    "\ufeff": "12",
    "title": "SR9",
    "size": 1,
    "group": 1,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "",
    "recommend": "",
    "full_title": "Elimination of carrier status"
  },
  {
    "\ufeff": "13",
    "title": "SR10",
    "size": 1,
    "group": 1,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "",
    "recommend": "",
    "full_title": "Frequency of exacerbations"
  },
  {
    "\ufeff": "14",
    "title": "SR11",
    "size": 1,
    "group": 1,
    "x_coord": 0,
    "y_coord": 0,
    "rad": 0,
    "doi": "",
    "recommend": "",
    "full_title": "Cost of care"
  }
];

var dataset_links = [
  {
    "\ufeff": "0",
    "origin": "G0",
    "termination": "SR0",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Eradication of MRSA",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "1",
    "origin": "G0",
    "termination": "SR2",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Lung function",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "2",
    "origin": "G0",
    "termination": "SR5",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Quality of Life",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "3",
    "origin": "G0",
    "termination": "SR8",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Adverse effects of treatment",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "4",
    "origin": "G0",
    "termination": "SR9",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Elimination of carrier status",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "5",
    "origin": "G1",
    "termination": "SR0",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Eradication of MRSA",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "6",
    "origin": "G1",
    "termination": "SR2",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Lung function",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "7",
    "origin": "G1",
    "termination": "SR3",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Overall antibiotic use",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "8",
    "origin": "G1",
    "termination": "SR4",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Mortality",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "9",
    "origin": "G1",
    "termination": "SR7",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Growth and nutritional status",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "10",
    "origin": "G1",
    "termination": "SR10",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Frequency of exacerbations",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "11",
    "origin": "G2",
    "termination": "SR0",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Eradication of MRSA",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "12",
    "origin": "G2",
    "termination": "SR2",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Lung function",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "13",
    "origin": "G2",
    "termination": "SR3",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Overall antibiotic use",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "14",
    "origin": "G2",
    "termination": "SR4",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Mortality",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "15",
    "origin": "G2",
    "termination": "SR5",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Quality of Life",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "16",
    "origin": "G2",
    "termination": "SR6",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Isolation of MRSA or other organisms with new antibiotic-resistant phenotypes",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "17",
    "origin": "G2",
    "termination": "SR7",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Growth and nutritional status",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "18",
    "origin": "G2",
    "termination": "SR8",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Adverse effects of treatment",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "19",
    "origin": "G2",
    "termination": "SR9",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Elimination of carrier status",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "20",
    "origin": "G2",
    "termination": "SR10",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Frequency of exacerbations",
    "line_style": 1,
    "agreement": 1
  },
  {
    "\ufeff": "21",
    "origin": "G2",
    "termination": "SR11",
    "commission": "",
    "otherEvidence": "",
    "line_col": 1,
    "line_opaque": 1,
    "topic": "Cost of care",
    "line_style": 1,
    "agreement": 1
  }
];


        ////////////////////////////////////////////////////////////////

        var w = window.innerWidth;
        var h = window.innerHeight - 110; // 110 is needed for the results table and the buttons
        var popup_w = 2 * w / 5 - 20;
        var popup_h = h / 3;  // previously this was:  h / 3 + 100;
        var circle_radius = 50;

        var line_width = 8;
        var line_dashed = "30, 10";

        var link_gap = 7;

        // define svg and diagonal as global 
        var svg = d3.select("body")
            .append("svg")
            .attr("width", w)
            .attr("height", h);
        console.log("svg defined");

        var diagonal = d3.svg.diagonal()
            // this sets up a variable containing
            // the diagonal function
            // note that the x and y are swapped round and then
            // swapped back with the .projection -
            // this is so that the diagonal curves in the right direction
            .source(function (d) {
                return {
                    "y": getXcoord(d.origin) + getRadius(d.origin) + link_gap,
                    "x": getYcoord(d.origin)
                };
            })
            .target(function (d) {
                return {
                    "y": getXcoord(d.termination) - getRadius(d.termination) - link_gap,
                    "x": getYcoord(d.termination)
                };
            })
            .projection(function (d) { return [d.y, d.x]; });

        

        // colours:-
        var left_outer_colour = "rgb(0, 101, 121)";
        var left_inner_colour = "rgb(0, 149, 161)";
        var left_lighter_colour = "rgb(100, 205, 205)";
        var left_faded_colour = "rgba(100, 205, 205, 0.5)"

        var right_outer_colour = "rgb(91, 41, 96)";
        var right_inner_colour = "rgb(145, 30, 179)";
        var right_lighter_colour = "rgb(199, 134, 219)";
        var right_faded_colour = "rgba(199, 134, 219, 0.2)"

        var link_highlight_colour = "rgb(0, 51, 102)"; // corp blue
        var link_standard_colour = "rgba(0, 51, 102, 0.4)";
        var link_faded_colour = "rgba(0, 51, 102, 0.1)";

        var link_highlight_colour_disagree = "rgb(136, 42, 13)"; //Arts dark
        var link_standard_colour_disagree = "rgba(136, 42, 13, 0.4)";
        var link_faded_colour_disagree = "rgba(136, 42, 13, 0.1)";

        var link_transparent_colour = "rgba(0, 0, 0, 0.0)"; // fully transparent

        var button_width = 220;
        var margin = 100; // distance from left button width 

        var group_3 = 0;
        var group_1 = 0;
        var group_0 = 0;

        var Antibiotic_therapy_col = "rgba(184, 204, 228, 1.0)"
        var Exacerbation_management_col = "rgba(184, 204, 228, 1.0)"
        var Pseudomonas_aeruginosa_col = "rgba(184, 204, 228, 1.0)"
        var Burkholderia_species_col = "rgba(184, 204, 228, 1.0)"
        var NTM_col = "rgba(184, 204, 228, 1.0)"
        var Stenotrophomonas_maltophilia_col = "rgba(184, 204, 228, 1.0)"
        var MRSA_col = "rgba(184, 204, 228, 1.0)"
        var Pneumococcus_col = "rgba(184, 204, 228, 1.0)"
        var Specific_Antibiotics_col = "rgba(184, 204, 228, 1.0)"
        var Antibiotic_prophylaxis_col = "rgba(184, 204, 228, 1.0)"
        var Inhaled_Antibiotics_col = "rgba(184, 204, 228, 1.0)"
        var Adjuncts_to_antibiotic_therapy_col = "rgba(184, 204, 228, 1.0)"
        var Management_of_ABPA_col = "rgba(184, 204, 228, 1.0)"
        var Viral_infections_col = "rgba(184, 204, 228, 1.0)"
        var Inflammation_col = "rgba(184, 204, 228, 1.0)"
        var Mucoactive_agents_col = "rgba(184, 204, 228, 1.0)"
        var Bronchodilators_col = "rgba(184, 204, 228, 1.0)"
        var Nebuliser_systems_col = "rgba(184, 204, 228, 1.0)"
        var NIV_col = "rgba(184, 204, 228, 1.0)"
        var Oxygen_col = "rgba(184, 204, 228, 1.0)"
        var Surgical_col = "rgba(184, 204, 228, 1.0)"
        var Pancreatic_Enzymes_col = "rgba(204, 192, 217, 1.0)"
        var Liver_disease_col = "rgba(204, 192, 217, 1.0)"
        var Nutritional_supplements_col = "rgba(204, 192, 217, 1.0)"
        var Appetite_col = "rgba(204, 192, 217, 1.0)"
        var Acid_management = "rgba(204, 192, 217, 1.0)"
        var Exercise_col = "rgba(214, 227, 188, 1.0)"
        var Physiotherapy_col = "rgba(214, 227, 188, 1.0)"
        var CF_related_arthritis_col = "rgba(251, 212, 180, 1.0)"
        var Osteoporosis_col = "rgba(251, 212, 180, 1.0)"
        var CF_related_diabetes_col = "rgba(182, 221, 232, 1.0)"
        var Growth_Hormone_col = "rgba(182, 221, 232, 1.0)"
        var Correction_of_basic_defect_col = "rgba(148, 54, 52, 1.0)"
        var Psychosocial_col = "rgba(166, 166, 166, 1.0)"
        var ENT_col = "rgba(150, 50, 102, 1.0)"

        // FUNCTION DEFINITIONS

        // Add this function to calculate maximum button width
        function calculateMaxButtonWidth() {
            // Define the padding you want on each side
            var padding = 20;
            
            // Create a temporary SVG text element for measurement
            var tempText = svg.append("text")
                .attr("font-family", "Helvetica")
                .attr("font-size", "14px")
                .style("opacity", 0); // Make it invisible
            
            var maxWidth = 0;
            
            // First collect all possible button texts
            var buttonTexts = [];
            
            // Get unique topics from dataset_links
            var uniqueTopics = [];
            for (var i = 0; i < dataset_links.length; i++) {
                var topic = dataset_links[i].topic;
                if (!uniqueTopics.includes(topic)) {
                    uniqueTopics.push(topic);
                    buttonTexts.push(topic);
                }
            }
            
            // Add other button texts
            buttonTexts.push("Reset");
            // Add any other fixed button texts here
            
            // Measure each text and find the maximum width
            for (var i = 0; i < buttonTexts.length; i++) {
                tempText.text(buttonTexts[i]);
                var width = tempText.node().getComputedTextLength();
                if (width > maxWidth) {
                    maxWidth = width;
                }
            }
            
            // Remove the temporary text element
            tempText.remove();
            
            // Calculate button width with padding
            var buttonWidth = maxWidth + (padding * 2);
            
            // Return the calculated width
            return buttonWidth;
        }

        function popupBottomText(page_number) {
            // function to popup the title of the 
            var coords = [0, 0];
            var dx = w / 2 - 50;
            var dy = h - 100;

            var rectangle = svg.append("rect")
                .attr("x", dx)
                .attr("y", dy)
                .attr("width", 100) // make it wide but 40 less than the current width
                .attr("height", 100)
                .attr("fill", function () {
                    return (left_faded_colour);
                })
                .attr("rx", 50)
                .attr("ry", 50)
                .attr("id", "popup_bottom_text")
                .style("pointer-events", "none")
                .on("click", function (d) {
                    page_number = page_number + 1;
                    removeBottomText();
                    removePopup();
                    writePage(page_number);
                });
            var rectangle = svg.append("rect")
                .attr("x", w - (150 + 5))
                .attr("y", h - (100 + 5))
                .attr("width", 140) //
                .attr("height", 100)
                .attr("fill", function () {
                    return (left_faded_colour);
                })
                .attr("rx", 50)
                .attr("ry", 50)
                .attr("id", "popup_bottom_text")
                .style("pointer-events", "none")
                .on("click", function (d) {
                    page_number = 12;
                    removeBottomText();
                    removePopup();
                    writePage(page_number);
                });

            var bottomText = svg.append("text")
                .attr('style', 'text-align:center; font-family:Helvetica; font-size:20px;')
                .attr("x", dx + 8)
                .attr("y", dy + 55)
                .attr('id', 'bottom_text')
                .text(function (d) {
                    var str = ("Continue");
                    return (str);
                })
                .style("cursor", "default");
            bottomText.on("click", function (d) {
                // if (page_number > )
                page_number = page_number + 1;
                // console.log(page_number);
                removeBottomText();
                removePopup();
                writePage(page_number);
            });
            var bottomText = svg.append("text")
                .attr('style', 'text-align:center; font-family:Helvetica; font-size:20px;')
                .attr("x", w - 130)
                .attr("y", h - 50)
                .attr('id', 'bottom_text')
                .text(function (d) {
                    var str = ("Skip intro...");
                    return (str);
                })
                .style("cursor", "default");
            bottomText.on("click", function (d) {
                // if (page_number > )
                page_number = 12;
                // console.log(page_number);
                removeBottomText();
                removePopup();
                writePage(page_number);
            });
        }

        function removePopup() {
            svg.selectAll("rect").remove();
            svg.selectAll("foreignObject").remove();
            svg.selectAll("xhtml").remove();
            var element = document.getElementById("multiline-title-text");
            if (element != null) {
                element.parentNode.removeChild(element);
            }
            var element = document.getElementById("bottom_text");
            element.parentNode.removeChild(element);
        }

        function popupBelow(this_var, node) {
            var rectangle = svg.append("rect")
                .attr("x", w / 8)
                .attr("y", h / 2 + 50)
                .attr("width", w * 6 / 8)
                .attr("height", 50)
                .attr("fill", function (d) {
                    if (node.group == 1) {
                        return (right_lighter_colour)
                    } else {
                        return (left_lighter_colour)
                    }
                })
                .attr("id", "below_popup_id")
                .attr("rx", 20)
                .attr("ry", 20)
                .style("pointer-events", "none");
            var popup_below_text = svg.append("text")
                .attr('style', 'text-align:center; font-family:Helvetica; font-size:20px;')
                .attr("x", w / 8 + 20)
                .attr("y", h / 2 + 50 + 30)
                .attr('id', 'below_popup_text_id')
                .text(function (d) {
                    var str = (node.title);
                    return (str);
                });
        }

        function removePopupBelow(this_var, node) {
            var element = document.getElementById("below_popup_id");
            element.parentNode.removeChild(element);
            var element = document.getElementById("below_popup_text_id");
            element.parentNode.removeChild(element);
        }


        function getXcoord(node) {
            // function to get the x co-ordinate of the
            // node stored in dataset
            var x_coord = 0;
            for (i = 0; i < dataset.length; i++) {
                if (dataset[i].title == node) {
                    x_coord = dataset[i].x_coord;
                }
            }
            return x_coord;
        }

        function getYcoord(node) {
            // function to get the y corordinate of the
            // node stored in dataset
            var y_coord = 0;
            for (i = 0; i < dataset.length; i++) {
                if (dataset[i].title == node) {
                    y_coord = dataset[i].y_coord;
                }
            }
            return y_coord;
        }

        function getRadius(node) {
            // function to get the radius of the
            // node stored in dataset
            var rad = 0;
            for (i = 0; i < dataset.length; i++) {
                if (dataset[i].title == node) {
                    rad = dataset[i].rad;
                }
            }
            return rad;
        }

        function highlightNodes(node) {
            for (i = 0; i < dataset_links.length; i++) {
                //change the colour variable in dataset_links
                if (dataset_links[i].origin == node || dataset_links[i].termination == node) {
                    dataset_links[i].line_col = "2";
                } else {
                    dataset_links[i].line_col = "0";
                }
            }
            svg.selectAll("#links")  //need to update the visuals - update all the paths
                .data(dataset_links)
                .style("stroke", function (d) {
                    if (d.line_opaque == 0) {
                        return (link_transparent_colour);
                    } else if (d.line_col == 1 && d.agreement == 1) {
                        return (link_standard_colour);
                    } else if (d.line_col == 1 && d.agreement == 4) {
                        return (link_standard_colour_disagree);
                    } else if (d.line_col == 0 && d.agreement == 1) {
                        return (link_faded_colour);
                    } else if (d.line_col == 0 && d.agreement == 4) {
                        return (link_faded_colour_disagree);
                    } else if (d.line_col == 2 && d.agreement == 1) {
                        return (link_highlight_colour);
                    } else if (d.line_col == 2 && d.agreement == 4) {
                        return (link_highlight_colour_disagree);
                    } else {
                        return ("blue");
                    }
                })
                ;
        }

        function unhighlightNodes() {
            for (i = 0; i < dataset_links.length; i++) {
                //reset the colours of all nodes
                dataset_links[i].line_col = "1";
            }
            svg.selectAll("#links")  //need to update the visuals - update all the paths
                .data(dataset_links)
                //.transition()
                //.duration(100)
                .style("stroke", function (d) {
                    if (d.line_opaque == 0) {
                        return (link_transparent_colour);
                    } else if (d.line_col == 1 && d.agreement == 1) {
                        return (link_standard_colour);
                    } else if (d.line_col == 1 && d.agreement == 4) {
                        return (link_standard_colour_disagree);
                    } else if (d.line_col == 0 && d.agreement == 1) {
                        return (link_faded_colour);
                    } else if (d.line_col == 0 && d.agreement == 4) {
                        return (link_faded_colour_disagree);
                    } else if (d.line_col == 2 && d.agreement == 1) {
                        return (link_highlight_colour);
                    } else if (d.line_col == 2 && d.agreement == 4) {
                        return (link_highlight_colour_disagree);
                    } else {
                        return ("blue");
                    }
                });
        }

        function fadeAllLinks() {
            //function to fade all the links
            svg.selectAll("#links")  //need to update the visuals - update all the paths
                .data(dataset_links)
                .style("stroke", function (d) {
                    if (d.line_opaque == 0) {
                        return (link_transparent_colour);
                    } else if (d.agreement == 1) {
                        return (link_faded_colour);
                    } else if (d.agreement == 4) {
                        return (link_faded_colour_disagree);
                    }
                })
                ;
        }

        function highlightLinks(link) {
            // function to highlight the link
            // and include the text in the upper boxes
            // first get the origin then
            // find the text associated with link.origin
            for (i = 0; i < dataset.length; i++) {
                if (dataset[i].title == link.origin) {
                    insertLeftText(dataset[i].recommend);
                }
                if (dataset[i].title == link.termination) {
                    insertRightText(dataset[i].recommend);
                }
            }
        }

        function updateCircleLocation() {
            transition_time = typeof transition_time !== 'undefined' ? transition_time : 5000;
            svg.selectAll("#nodes")
                .data(dataset)
                .transition()
                .duration(transition_time)
                .attr("cx", function (d) {
                    return (d.x_coord);
                })
                .attr("cy", function (d) {
                    return (d.y_coord);
                });
        }

        function updateLineLocation(transition_time) {
            transition_time = typeof transition_time !== 'undefined' ? transition_time : 5000;
            svg.selectAll("#links")
                .data(dataset_links)
                .transition()
                .duration(transition_time)
                .attr("d", diagonal)
                .style("stroke", function (d) {
                    if (d.line_opaque == 0) {
                        return (link_transparent_colour);
                    } else if (d.line_col == 1 && d.agreement == 1) {
                        return (link_standard_colour);
                    } else if (d.line_col == 1 && d.agreement == 4) {
                        return (link_standard_colour_disagree);
                    } else if (d.line_col == 0 && d.agreement == 1) {
                        return (link_faded_colour);
                    } else if (d.line_col == 0 && d.agreement == 4) {
                        return (link_faded_colour_disagree);
                    } else if (d.line_col == 2 && d.agreement == 1) {
                        return (link_highlight_colour);
                    } else if (d.line_col == 2 && d.agreement == 4) {
                        return (link_highlight_colour_disagree);
                    } else {
                        return ("blue");
                    }
                });
        }

        function update_groups() {
            group_0 = 0;
            group_1 = 1;
            for (i = 0; i < dataset.length; i++) {
                if (dataset[i].group == 0) {
                    group_0 = group_0 + 1;
                } else if (dataset[i].group == 1) {
                    group_1 = group_1 + 1;
                }
            }
        }

        function setSquareArrangement() {
            // loop to empirically set the square node positions
            // note this calls and adjusts the global variables
            // first reset the data
            group_0_counter = 0;
            group_1_counter = 1;

            // Adjust these values to control the horizontal position
            var left_offset  = button_width + margin;  // Changed from w/3 to w/4 (smaller value = closer to center)
            var right_offset =  margin; // Changed from w/3 to w/4
            
            for (i = 0; i < dataset.length; i++) {
                if (dataset[i].group == 0) {
                    group_0_counter = group_0_counter + 1;
                    dataset[i].x_coord = left_offset;  // Use the new variable
                    dataset[i].y_coord = (group_0_counter) * (h * 0.9) / (group_0 + 1);

                } else if (dataset[i].group == 1) {
                    group_1_counter = group_1_counter + 1;
                    dataset[i].x_coord = w - right_offset;  // Use the new variable
                    dataset[i].y_coord = (group_1_counter) * (h * 0.9) / (group_1 + 1);
                }
            }
        }

        function setCircleArrangement() {
            // loop to set the circular node positions
            // note this calls and adjusts the global variables
            // makes use of group_0, and group_1
            // need to use group_1_counter and group_0_counter
            //   to keep track of the groups (in case they're 
            //   in funny orders)
            // circle offset is amount of the bottom and top of the circle to leave off
            // console.log("in set circle arangement");
            var circle_offset = 0.3;
            var separation = 50;
            var group_0_counter = Math.round(circle_offset / 2 * group_0);
            var group_1_counter = Math.round(circle_offset / 2 * group_1);
            var centre_x = w / 2 + button_width /2;
            var centre_y = h / 2;
            var left_offset  = button_width + margin;

            var radius_option1 = h * 0.45;  // Original height-based radius
            var radius_option2 = (w / 2) - (left_offset / 2); // Width-based radius considering buttons
            
            // Use the smaller of the two values
            var rad = Math.min(radius_option1, radius_option2) * 0.9;
            console.log("debugging setCicleArrangement");
            console.log(h);
            console.log(w);
            console.log(rad);
            for (i = 0; i < dataset.length; i++) {
                if (dataset[i].group == 0) {
                    dataset[i].x_coord = centre_x - separation - rad * Math.sin((group_0_counter * (3.14159265 / (group_0 + Math.round(circle_offset * group_0)))));
                    dataset[i].y_coord = centre_y - rad * Math.cos((group_0_counter * (3.14159265 / (group_0 + Math.round(circle_offset * group_0)))));
                    group_0_counter = group_0_counter + 1;
                } else if (dataset[i].group == 1) {
                    dataset[i].x_coord = centre_x + separation + (rad) * Math.sin((group_1_counter * (3.14159265 / (group_1 + Math.round(circle_offset * group_1)))));
                    dataset[i].y_coord = centre_y - (rad) * Math.cos((group_1_counter * (3.14159265 / (group_1 + Math.round(circle_offset * group_1)))));
                    group_1_counter = group_1_counter + 1;
                }
            }
        }

        function showAllSquare() {
            // make the nodes and links move into a square arrangement
            resetGroups();
            update_groups();
            setSquareArrangement();
            updateCircleLocation();
            updateLineLocation();
        }

        function showAllCircle() {
            resetGroups();
            update_groups();
            setCircleArrangement();
            updateCircleLocation();
            updateLineLocation();
        }

        function disAppearAllNodes() {
            // change the location of the nodes so that they are all off screen
            for (i = 0; i < dataset.length; i++) {
                dataset[i].y_coord = h + 200;
            }
            updateCircleLocation();
            updateLineLocation();
        }

        function getTopic(topic_string) {
            // console.log("In the getTopic() function")
            // console.log(topic_string)
            // function to put all the nodes in topic_string in, and put everyone else in group_2
            // first reset the data
            resetGroups(); // reset the groups
            // steps;
            // go through the dataset and set everyone to group 2 and move them all off screen

            for (let i = 0; i < dataset.length; i++) {
                dataset[i].group = 2;
                dataset[i].y_coord = h + 200;
            }
            // go through the dataset_links
            // for each row find if the topic == asthma
            for (let i = 0; i < dataset_links.length; i++) {
                if (dataset_links[i].topic == topic_string) {
                    // if topic is asthma get the guideline to group 1 and the cr to group 0
                    for (let j = 0; j < dataset.length; j++) {
                        if (dataset[j].title == dataset_links[i].origin) {
                            dataset[j].group = 0;
                        } else if (dataset[j].title == dataset_links[i].termination) {
                            dataset[j].group = 1;
                        }
                    }
                }
            }
            // reset the group variables and re_count the groups
            group_0 = 0;
            group_1 = 0;
            for (i = 0; i < dataset.length; i++) {
                if (dataset[i].group == 0) {
                    group_0 = group_0 + 1;
                } else if (dataset[i].group == 1) {
                    group_1 = group_1 + 1;
                }
            }
            changeColourExcludedGroups();
            setSquareArrangement();
            updateCircleLocation();
            updateLineLocation();
        }

        function getCommissioner(commission_string) {
            // function to put all the asthmas in, and put everyone else in group_2
            // first reset the data
            resetGroups(); // reset the groups
            // steps;
            // go through the dataset and set everyone to group 2 and move them all off screen

            for (i = 0; i < dataset.length; i++) {
                dataset[i].group = 2;
                dataset[i].y_coord = h + 200;
            }
            // go through the dataset_links
            // for each row find if the topic == asthma
            for (i = 0; i < dataset_links.length; i++) {
                if (dataset_links[i].commission == commission_string) {
                    // if commissioner is the right one get the guideline to group 1 and the cr to group 0
                    for (j = 0; j < dataset.length; j++) {
                        if (dataset[j].title == dataset_links[i].origin) {
                            dataset[j].group = 0;
                        } else if (dataset[j].title == dataset_links[i].termination) {
                            dataset[j].group = 1;
                        }
                    }
                }
            }
            // reset the group variables and re_count the groups
            group_0 = 0;
            group_1 = 0;
            for (i = 0; i < dataset.length; i++) {
                if (dataset[i].group == 0) {
                    group_0 = group_0 + 1;
                } else if (dataset[i].group == 1) {
                    group_1 = group_1 + 1;
                }
            }
            changeColourExcludedGroups();
            setCircleArrangement();
            updateCircleLocation();
            updateLineLocation();
        }

        function getDisagree() {
            // function to make all agreeing lines transparent

            for (i = 0; i < dataset_links.length; i++) {
                if (dataset_links[i].agreement == 1) {
                    dataset_links[i].line_opaque = 0;
                }
            }
            updateLineLocation(transition_time = 5000);
        }

        function getIgnored() {
            // function to show only the links with evidence ignored
            for (i = 0; i < dataset_links.length; i++) {
                if (dataset_links[i].line_style == 1) {
                    // remove the full lines
                    dataset_links[i].line_opaque = 0;
                }
            }
            updateLineLocation(transition_time = 5000);
        }

        function changeColourExcludedGroups() {
            for (i = 0; i < dataset_links["length"]; i++) {
                // loop over the dataset_links origins and terminations
                // if either are group 2 then set the line colour to 0
                for (j = 0; j < dataset.length; j++) {
                    if (dataset[j].title == dataset_links[i].origin || dataset[j].title == dataset_links[i].termination) {
                        if (dataset[j].group == 2) {
                            dataset_links[i].line_opaque = 0;
                        }
                    }
                }
            }
        }



        function resetGroups() {
            // function which loops through dataset
            // and resets all Gaps to 0 and Systematic reviews to 1
            for (i = 0; i < dataset.length; i++) {
                if (dataset[i].title.substring(0, 1) == "S") {
                    dataset[i].group = 1;
                } else if (dataset[i].title.substring(0, 1) == "G") {
                    dataset[i].group = 0;
                }
            }
            for (i = 0; i < dataset_links.length; i++) {
                dataset_links[i].line_opaque = 1;
            }
        }

        function popupString(this_var, link) {
            // function to popup the rectangles with the strings in
            // in this version it is just on the right
            var coords = [0, 0];
            coords = d3.mouse(this_var);

            //left rectangle:-
            var rectangle = svg.append("rect")
                .attr("x", 2)
                .attr("y", function () {
                    if (coords[1] > h / 2) {
                        return (coords[1] - popup_h);
                    } else {
                        return (coords[1]);
                    }
                })
                .attr("width", popup_w)
                .attr("height", popup_h)
                .attr("fill", left_lighter_colour)
                .attr("rx", 20)
                .attr("ry", 20)
                .attr("id", "popup-string-id")
                .style("pointer-events", "none");
            // insert text on the left:
            var ldx = 10;
            var leftText = svg.append("text")
                .attr('style', 'text-align:left; font-family:Helvetica; font-size:15px;')
                .attr('id', 'multiline-left-text')
                .attr("x", ldx)
                .attr("y", function () {
                    if (coords[1] > h / 2) {
                        return (coords[1] - popup_h + 30);
                    } else {
                        return (coords[1] + 30);
                    }
                })
                .text(""); // empty text instead of a placeholder
            var new_text = "";
            for (i = 0; i < dataset.length; i++) {
                if (dataset[i].title == link.origin) {
                    new_text = dataset[i].full_title;
                    // console.log(new_text);
                    // console.log("Left node = ");
                    // console.log(dataset[i].title);
                }
            }
            createMultiLineLeft("Research: ".concat(new_text), ldx);

            // right rectangle
            var rectangle = svg.append("rect")
                .attr("x", w - (popup_w + 2))
                .attr("y", function () {
                    if (coords[1] > h / 2) {
                        return (coords[1] - popup_h);
                    } else {
                        return (coords[1]);
                    }
                })
                .attr("width", (popup_w))
                .attr("height", (popup_h))
                .attr("fill", right_lighter_colour)
                .attr("rx", 20)
                .attr("ry", 20)
                .attr("id", "popup-string-id")
                .style("pointer-events", "none");

            var dx = w - (popup_w - 10);
            var rightText = svg.append("text")
                .attr('style', 'text-align:left; font-family:Helvetica; font-size:15px;')
                .attr('id', 'multiline-right-text')
                .attr("x", dx)
                .attr("y", function () {
                    if (coords[1] > h / 2) {
                        return (coords[1] - popup_h + 30);
                    } else {
                        return (coords[1] + 30);
                    }
                })
                .attr("width", popup_w - 10)
                .attr("height", popup_h)
                .text("");
            var new_text = "";
            for (i = 0; i < dataset.length; i++) {
                if (dataset[i].title == link.termination) {
                    new_text = dataset[i].full_title;
                    // console.log("Right node = ")
                    // console.log(dataset[i].title);
                }
            }
            createMultiLineRight("Topic: ".concat(new_text), dx);

            // reason in the middle!!

            var rectangle = svg.append("rect")
                .attr("x", w / 2 - (popup_w * .5 / 2))
                .attr("y", function () {
                    if (coords[1] > h / 2) {
                        return (coords[1] - popup_h * 1.6);
                    } else {
                        return (coords[1]);
                    }
                })
                .attr("width", (popup_w * .5))
                .attr("height", (popup_h * 1.6))
                .attr("fill", link_standard_colour)
                .attr("rx", 20)
                .attr("ry", 20)
                .attr("id", "popup-string-id")
                .style("pointer-events", "none");

            var mdx = w / 2 - (popup_w * .5 / 2) + 10;

            var middleText = svg.append("text")
                .attr('style', 'text-align:left; font-family:Helvetica; font-size:10px;')
                .attr('id', 'multiline-middle-text')
                .attr("x", mdx)
                .attr("y", function () {
                    if (coords[1] > h / 2) {
                        return (coords[1] - popup_h * 1.6 + 30);
                    } else {
                        return (coords[1] + 30);
                    }
                })
                .attr("width", popup_w - 10)
                .attr("height", popup_h)
                .text("");
            var new_text = "";
            //console.log(new_text);
            // console.log("link.termination = ")
            //console.log(link.termination);
            for (i = 0; i < dataset.length; i++) {
                if (dataset[i].title == link.origin) {
                    // console.log("Middle node identified.  The next three logs should be dataset[i].title and dataset[i].recommend and i.");
                    //console.log(dataset[i].title);
                    //console.log(dataset[i].recommend);
                    //console.log(i);
                    new_text = dataset[i].recommend;
                }
            }
            //console.log(new_text);
            createMultiLineMiddle(new_text, mdx);

        }

        function createMultiLineMiddle(text, mdx) {
            var words = text.split(' ');

            // Get dimensions of the rectangle
            var text_width = popup_w * .5 - 20;
            var rectangle_height = popup_h * 1.6; // Match the height of the middle rectangle
            var line_height = 18; // Height of each line of text
            var initial_y_offset = 30; // Initial y position where text starts
            
            // Calculate maximum number of lines that can fit in the rectangle
            var max_lines = Math.floor((rectangle_height - initial_y_offset) / line_height);
            
            var text_element = document.getElementById("multiline-middle-text");
            text_element.textContent = "";
            text_element.setAttribute('style', 'text-align:left; font-family:Helvetica; font-weight:bold; font-size:12px;')
            
            // Create first tspan element
            var current_tspan = document.createElementNS(svgNS, "tspan");
            var text_node = document.createTextNode(words[0] || "");
            
            current_tspan.appendChild(text_node);
            text_element.appendChild(current_tspan);

            var lines_count = 0;
            
            for (var i = 1; i < words.length; i++) {
                // Store current length before adding new word
                var len = current_tspan.firstChild.data.length;
                
                // Try adding the next word
                current_tspan.firstChild.data += " " + words[i];
                
                // Check if it's too long for the width
                if (current_tspan.getComputedTextLength() > text_width) {
                    // Remove the added word (restore to previous length)
                    current_tspan.firstChild.data = current_tspan.firstChild.data.slice(0, len);
                    
                    // Increment line count
                    lines_count += 1;
                    
                    // Check if we've hit the maximum number of lines that can fit
                    if (lines_count >= max_lines - 1) { // Leave one line for ellipsis
                        // Add ellipsis to indicate truncation
                        current_tspan.firstChild.data += "...";
                        break; // Stop processing more words
                    }
                    
                    // Create a new tspan for the next line
                    var next_tspan = document.createElementNS(svgNS, "tspan");
                    next_tspan.setAttributeNS(null, "x", mdx);
                    next_tspan.setAttributeNS(null, "dy", line_height);
                    
                    // Add the current word to the new line
                    var new_text_node = document.createTextNode(words[i]);
                    next_tspan.appendChild(new_text_node);
                    text_element.appendChild(next_tspan);
                    
                    // Update the current tspan reference
                    current_tspan = next_tspan;
                }
            }
        }
        function createMultiLineLeft(text, ldx) {
            // Handle null or empty text
            if (!text || text.trim() === "") {
                text = ""; // Set to empty string
            }
            var words = text.split(' ');

            var text_width = popup_w - 20;
            var text_element = document.getElementById("multiline-left-text");
            text_element.textContent = "";
            text_element.setAttribute('style', 'text-align:left; font-family:Helvetica; font-size:20px;')
            var tspan_element = document.createElementNS(svgNS, "tspan");   // Create first tspan element
            var text_node = document.createTextNode(words[0]);           // Create text in tspan element

            tspan_element.appendChild(text_node);                           // Add tspan element to DOM
            text_element.appendChild(tspan_element);

            var lines_count = 0;  // this variable sets how many lines high it can be
            for (var i = 1; i < words.length; i++) {

                var len = tspan_element.firstChild.data.length;             // Find number of letters in string
                tspan_element.firstChild.data += " " + words[i];            // Add next word

                if (tspan_element.getComputedTextLength() > text_width) {
                    tspan_element.firstChild.data = tspan_element.firstChild.data.slice(0, len); 				// Remove added word
                    lines_count = lines_count + 1;
                    if (lines_count > 13) {
                        tspan_element.firstChild.data = tspan_element.firstChild.data.slice(0, len);  // remove another word
                        tspan_element.firstChild.data += "...";  // add '...'
                        break; // break out of the for loop
                    }
                    var tspan_element = document.createElementNS(svgNS, "tspan");				// Create new tspan element
                    tspan_element.setAttributeNS(null, "x", ldx);
                    tspan_element.setAttributeNS(null, "dy", 20);
                    text_node = document.createTextNode(words[i]);
                    tspan_element.appendChild(text_node);
                    text_element.appendChild(tspan_element);

                }
            }
        }

        function createMultiLineRight(text, dx) {
            var words = text.split(' ');

            var text_width = popup_w - 20;
            var text_element = document.getElementById("multiline-right-text");
            text_element.setAttribute('style', 'text-align:left; font-family:Helvetica; font-size:20px;')
            text_element.textContent = "";
            var tspan_element = document.createElementNS(svgNS, "tspan");   // Create first tspan element
            var text_node = document.createTextNode(words[0]);           // Create text in tspan element

            tspan_element.appendChild(text_node);                           // Add tspan element to DOM
            text_element.appendChild(tspan_element);
            var lines_count = 0;
            for (var i = 1; i < words.length; i++) {
                var len = tspan_element.firstChild.data.length;             // Find number of letters in string
                tspan_element.firstChild.data += " " + words[i];            // Add next word

                if (tspan_element.getComputedTextLength() > text_width) {
                    lines_count = lines_count + 1;
                    if (lines_count > 13) {
                        tspan_element.firstChild.data = tspan_element.firstChild.data.slice(0, len);  // remove another word
                        tspan_element.firstChild.data += "...";  // add '...'
                        break; // break out of the for loop
                    }
                    tspan_element.firstChild.data = tspan_element.firstChild.data.slice(0, len);    // Remove added word
                    var tspan_element = document.createElementNS(svgNS, "tspan");       // Create new tspan element
                    tspan_element.setAttributeNS(null, "x", dx);
                    tspan_element.setAttributeNS(null, "dy", 20);
                    text_node = document.createTextNode(words[i]);
                    tspan_element.appendChild(text_node);
                    text_element.appendChild(tspan_element);
                }
            }
        }

        function popupTitle(this_var, title, group, full_title) {
            // function to popup the title of the 
            var coords = [0, 0];
            coords = d3.mouse(this_var);
            var dx = 20;
            var dy = 0;
            // we could use this code below to determine if this is a left node or a right node 
            // swapping height for width
            if (coords[1] > h / 2) {
                dy = 20;
            } else {
                dy = h - 120; // height = 100
            }

            // left rectangle
            var rectangle = svg.append("rect")
                .attr("x", 2)
                .attr("y", function () {
                    if (coords[1] > h / 2) {
                        return (coords[1] - popup_h);
                    } else {
                        return (coords[1]);
                    }
                })
                .attr("width", popup_w)
                .attr("height", popup_h)
                .attr("fill", left_lighter_colour)
                .attr("rx", 20)
                .attr("ry", 20)
                .attr("id", "popup-string-id")
                .style("pointer-events", "none");

            // insert text on the left 
            var ldx = 10;
            var leftText = svg.append("text")
                .attr('style', 'text-align:left; font-family:Helvetica; font-size:15px;')
                .attr('id', 'multiline-left-text')
                .attr("x", ldx)
                .attr("y", function () {
                    if (coords[1] > h / 2) {
                        return (coords[1] - popup_h + 30);
                    } else {
                        return (coords[1] + 30);
                    }
                })
                .text("");
            var new_text = "";
            // console.log("full_title:");
            //console.log(full_title);
            // console.log("new_text:")
            //console.log(new_text);
            new_text = full_title;
            //console.log(new_text);
            createMultiLineLeft("Research: ".concat(new_text), ldx);
        }

        function createPopup(text, dx) {
            var words = text.split(' ');
            var text_width = w - 100;
            var text_element = document.getElementById("multiline-title-text");
            text_element.textContent = "";
            text_element.setAttribute('style', 'font-family:Helvetica; font-size:20px;')
            var tspan_element = document.createElementNS(svgNS, "tspan");   // Create first tspan element
            var text_node = document.createTextNode(words[0]);           // Create text in tspan element

            tspan_element.appendChild(text_node);                           // Add tspan element to DOM
            text_element.appendChild(tspan_element);

            var lines_count = 0;  // this variable sets how many lines high it can be
            for (var i = 1; i < words.length; i++) {
                var len = tspan_element.firstChild.data.length;             // Find number of letters in string
                tspan_element.firstChild.data += " " + words[i];            // Add next word

                if (tspan_element.getComputedTextLength() > text_width) {
                    tspan_element.firstChild.data = tspan_element.firstChild.data.slice(0, len); 				// Remove added word
                    lines_count = lines_count + 1;
                    if (lines_count > 5) {  //don't go over this number of lines
                        tspan_element.firstChild.data = tspan_element.firstChild.data.slice(0, len);  // remove another word
                        tspan_element.firstChild.data += "...";  // add '...'
                        break; // break out of the for loop
                    }
                    var tspan_element = document.createElementNS(svgNS, "tspan");				// Create new tspan element
                    tspan_element.setAttributeNS(null, "x", dx);
                    tspan_element.setAttributeNS(null, "dy", 20);
                    text_node = document.createTextNode(words[i]);
                    tspan_element.appendChild(text_node);
                    text_element.appendChild(tspan_element);

                }
            }
        }

        function removeBottomText() {
            var element = document.getElementById("bottom_text");
            if (element != null) {
                element.parentNode.removeChild(element);
            }
        }

        function removePopup() {
            svg.selectAll("rect").remove();
            var element = document.getElementById("multiline-title-text");
            element.parentNode.removeChild(element);
        }

        function removePopupMain() {
            // this removes the popups from the main function
            var element = document.getElementById("multiline-title-text");
            if (element != null) {
                element.parentNode.removeChild(element);
            }
            var element_exists = 1;
            var i = 0;
            while (element_exists == 1) {
                i = i + 1;
                var element = document.getElementById("popup-title-id");
                if (element != null) {
                    //console.log(i);
                    element.parentNode.removeChild(element);
                } else {
                    element_exists = 0;
                    // console.log("in removePopupMain... no popups left")
                }
            }
        }

        function removeString() {
            //do stuff to remove all the popup strings on the page
            svg.selectAll("foreignObject").remove();
            svg.selectAll("xhtml").remove();
            var element = document.getElementById("multiline-right-text");
            if (element != null) {
                element.parentNode.removeChild(element);
            }
            var element = document.getElementById("multiline-left-text");
            if (element != null) {
                element.parentNode.removeChild(element);
            }
            var element = document.getElementById("multiline-middle-text");
            if (element != null) {
                element.parentNode.removeChild(element);
            }
            var element_exists = 1;
            var i = 0;
            while (element_exists == 1) {
                i = i + 1;
                var element = document.getElementById("popup-string-id");
                if (element != null) {
                    //console.log(i);
                    element.parentNode.removeChild(element);
                } else {
                    element_exists = 0;
                    // console.log("in removeString... no popups left")
                }
            }
        }

 

        function drawButton(y_pos, button_text, function_call, fcol, fontcol) {
            // Default colors if not provided
            fontcol = (typeof fontcol !== 'undefined') ? fontcol : "black";
            fcol = (typeof fcol !== 'undefined') ? fcol : Antibiotic_therapy_col;

            // Create a group to hold both rectangle and text
            var buttonGroup = svg.append("g")
                .attr("class", "button-group");
            
            // Add rectangle to group
            var button_rect = buttonGroup.append("rect")
                .attr("x", 0)
                .attr("y", y_pos + 5)
                .attr("width", button_width)
                .attr("height", 25)
                .attr("fill", fcol)
                .attr("stroke", "gray")
                .attr("rx", 5)
                .attr("ry", 5)
                .on("click", function () {
                    eval(function_call);
                })
                .on("mouseover", function() {
                    // Highlight effect on mouseover
                    d3.select(this)
                        .attr("stroke", "#333333")
                        .attr("stroke-width", 2);
                        
                    // Also highlight the text
                    d3.select(this.parentNode).select('text')
                        .attr('style', 'text-align:center; font-family:Helvetica; font-size:14px; font-weight:bold; fill:' + fontcol);
                })
                .on("mouseout", function() {
                    // Return to original style on mouseout
                    d3.select(this)
                        .attr("stroke", "gray")
                        .attr("stroke-width", 1);
                        
                    // Return text to normal
                    d3.select(this.parentNode).select('text')
                        .attr('style', 'text-align:center; font-family:Helvetica; font-size:14px; font-weight:normal; fill:' + fontcol);
                });

            // Add text to the same group
            var button_text = buttonGroup.append("text")
                .attr('style', 'text-align:center; font-family:Helvetica; font-size:14px; font-weight:normal; fill:' + fontcol)
                .attr("x", 5)
                .attr("y", y_pos + 5 + 14)
                .attr('id', 'button_text')
                .text(function (d) {
                    return (button_text);
                })
                .style("cursor", "default")
                .on("click", function () {
                    eval(function_call);
                })
                .on("mouseover", function() {
                    // Highlight the rectangle when text is hovered
                    d3.select(this.parentNode).select('rect')
                        .attr("stroke", "#333333")
                        .attr("stroke-width", 2);
                        
                    // Update text style
                    d3.select(this)
                        .attr('style', 'text-align:center; font-family:Helvetica; font-size:14px; font-weight:bold; fill:' + fontcol);
                })
                .on("mouseout", function() {
                    // Return rectangle to original style
                    d3.select(this.parentNode).select('rect')
                        .attr("stroke", "gray")
                        .attr("stroke-width", 1);    
                        
                    // Return text to original style
                    d3.select(this)
                        .attr('style', 'text-align:center; font-family:Helvetica; font-size:14px; font-weight:normal; fill:' + fontcol);
                });
        }


        function drawAllButtons() {
            var z = 0;
            var big_space = 30;
            var small_space = 26;

            var uniqueTopics = []; // Array to store unique topics

            for (var i = 0; i < dataset_links.length; i++) {
                var topic = dataset_links[i].topic;
                var buttonText = dataset_links[i].topic;
                var onClickAction = "getTopic('" + topic + "');";

                if (!uniqueTopics.includes(topic)) {
                    // Draw the button only if the topic is not already included
                    drawButton(z, buttonText, onClickAction, "white");
                    uniqueTopics.push(topic); // Add the topic to the uniqueTopics array
                    z = z + small_space;
                }
            }

            z = z + big_space;
            drawButton(z, "Reset", "showAllCircle();", "white");
            z = z + big_space;
        }


        function setLineStyle() {
            // function to loop over the links and set the line style
            // console.log("in setLineStyle")
            for (i = 0; i < dataset_links.length; i++) {
                if (dataset_links[i].commission == "No Trials") {
                    dataset_links[i].line_style = 2;
                }
            }
        }

        function getTopicForNode(nodeTitle) {
            // Search through dataset_links to find the topic
            for (let i = 0; i < dataset_links.length; i++) {
                // If this link points to the node we're looking for
                if (dataset_links[i].termination == nodeTitle) {
                    // Return the topic of this link
                    return dataset_links[i].topic;
                }
            }
            // If no topic was found
            return null;
        }

        function runFigure() {
            removeBottomText();
            drawAllButtons();
            setLineStyle();

            svg.selectAll("circle")
                .data(dataset) //may as well use this as the index
                .enter()
                .append("circle")
                .attr("id", "nodes")
                .attr("cx", function (d) {
                    return (d.x_coord);
                })
                .attr("cy", function (d) {
                    return (d.y_coord);
                })
                .attr("r", function (d, i) {
                    d.rad = Math.sqrt(dataset[i].size * circle_radius)
                    return (d.rad);
                })
                .attr("stroke-width", 2)
                .attr("fill", function (d, i) {
                    if (dataset[i].group == 0) {
                        return (left_inner_colour);
                    } else {
                        return (right_inner_colour);
                    }
                })
                .attr("stroke", function (d, i) {
                    if (dataset[i].group == 0) {
                        return (left_outer_colour);
                    } else {
                        return (right_outer_colour);
                    }
                })
                .on("click", function (d, i) {
                    if (dataset[i].group == 0) {
                        //console.log(dataset[i].title);
                        //console.log(dataset[i].recommend);
                        window.open((dataset[i].doi));
                    } else if (dataset[i].group == 1) {
                        // console.log("click detected - datset[i]==1");
                        //console.log(dataset[i].title);
                        // work out the topic 
                        var nodeTopic = getTopicForNode(dataset[i].title);
                        // console.log("node topic = ")
                        //console.log(nodeTopic)
                        if (nodeTopic) {
                            // Call the getTopic function with this topic
                            getTopic(nodeTopic);
                        }

                    }
                })
                .on("mouseover", function () {
                    d3.select(this)
                        .attr("fill", function (d) {
                            // logic to fill the circle and call
                            // highlight nodes and write text
                            highlightNodes(d.title);
                            popupTitle(this, d.title, d.group, d.full_title);
                            // console.log("Node = ");
                            //console.log(d.title);
                            if (d.group == 0) {
                                return (left_outer_colour);
                            } else {
                                return (right_outer_colour);
                            }
                        })

                })
                .on("mouseout", function () {
                    var thisElement = this;
                    setTimeout(function() {
                        d3.select(thisElement)
                        .attr("fill", function (d) {
                            removeString();
                            unhighlightNodes();
                            removePopupMain();
                            if (d.group == 0) {
                                return (left_inner_colour);
                            } else {
                                return (right_inner_colour);
                            }
                            });
                    }, 50); // 50ms delay
                });



            svg.selectAll("path")
                .data(dataset_links) //may as well use this as the index
                .enter()
                .append("path")
                .attr("d", diagonal)
                .attr("id", "links")
                .style("stroke-linecap", "round")
                .style("fill", "none")
                .style("stroke", function (d) {
                    if (d.line_opaque == 0) {
                        return (link_transparent_colour);
                    } else if (d.line_col == 1 && d.agreement == 1) {
                        return (link_standard_colour);
                    } else if (d.line_col == 1 && d.agreement == 4) {
                        return (link_standard_colour_disagree);
                    } else if (d.line_col == 0 && d.agreement == 1) {
                        return (link_faded_colour);
                    } else if (d.line_col == 0 && d.agreement == 4) {
                        return (link_faded_colour_disagree);
                    } else if (d.line_col == 2 && d.agreement == 1) {
                        return (link_highlight_colour);
                    } else if (d.line_col == 2 && d.agreement == 4) {
                        return (link_highlight_colour_disagree);
                    } else {
                        return ("blue");
                    }
                })
                .style("stroke-dasharray", function (d) {
                    if (d.line_style == 1) {
                        return ("5, 0");
                    } else if (d.line_style == 2) {
                        return (line_dashed);
                    }
                })
                .style("stroke-width", line_width)
                .on("mouseover", function () {
                    // don't do mouse overs if the line is transparent!
                    d3.select(this)
                        .style("stroke", function (d) {
                            if (d.line_opaque == 0) {
                                return (link_transparent_colour);
                            }
                            popupString(this, d);
                            // highlightLinks(d);
                            fadeAllLinks();
                            if (d.agreement == 1) {
                                return (link_highlight_colour);
                            } else if (d.agreement == 4) {
                                return (link_highlight_colour_disagree);
                            }
                        })
                })
                .on("mouseout", function () {
                    var thisElement = this;
                    // don't do mouse overs if the line is transparent!
                    setTimeout(function() {
                        d3.select(thisElement)
                        .style("stroke", function (d) {
                            if (d.line_opaque == 0) {
                                return (link_transparent_colour);
                            }
                            removeString();
                            unhighlightNodes();
                            if (d.line_col == 1 && d.agreement == 1) {
                                return (link_standard_colour);
                            } else if (d.line_col == 1 && d.agreement == 4) {
                                return (link_standard_colour_disagree);
                            } else if (d.line_col == 0 && d.agreement == 1) {
                                return (link_faded_colour);
                            } else if (d.line_col == 0 && d.agreement == 4) {
                                return (link_faded_colour_disagree);
                            } else if (d.line_col == 2 && d.agreement == 1) {
                                return (link_highlight_colour);
                            } else if (d.line_col == 2 && d.agreement == 4) {
                                return (link_highlight_colour_disagree);
                            } else {
                                return ("blue");
                            }
                        })
                    }, 50) // this is the delay of 50 ms
                });
        }

        //Functions to download the data:
        // Function to read and parse the XLSX file
        function importXLSX(file, callback) {
            var reader = new FileReader();

            reader.onload = function (event) {
                var data = new Uint8Array(event.target.result);
                var workbook = XLSX.read(data, { type: "array" });
                var worksheet = workbook.Sheets[workbook.SheetNames[0]];
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                var headers = jsonData[0]; // Extract the first row as headers
                var dataArray = jsonData.slice(1); // Remove the first row from the data

                var result = dataArray.map(function (row) {
                    var obj = {};
                    headers.forEach(function (header, index) {
                        obj[header] = row[index];
                    });
                    return obj;
                });

                callback(result);
            };

            reader.readAsArrayBuffer(file);
        }

        // Handle file selection event for dataset file
        function handledatasetFileSelect(event) {
            var file = event.target.files[0];
            importXLSX(file, function (jsonData) {
                dataset = jsonData; // Store dataset data in the 'dataset' variable
                hideFileInput('datasetButton');
            });
        }

        // Handle file selection event for dataset_links file
        function handledataset_linksFileSelect(event) {
            var file = event.target.files[0];
            importXLSX(file, function (jsonData) {
                dataset_links = jsonData; // Store dataset_links data in the 'dataset_links' variable
                hideFileInput('dataset_linksButton');
            });
        }

        // Function to hide button element by ID
        function hideFileInput(buttonId) {
            var button = d3.select("#" + buttonId);
            button.style("display", "none");
        }

        // Function to trigger file input click event
        function triggerFileInputClick(inputId) {
            var fileInput = document.getElementById(inputId);
            fileInput.click();
        }

        // Create D3 button for file input
        function createFileInputButton(buttonId, inputId, buttonText) {
            var buttonContainer = d3.select("body")
                .append("div")
                .attr("id", buttonId)
                .attr("class", "custom-button-container");

            buttonContainer.append("button")
                .attr("class", "custom-button")
                .text(buttonText)
                .on("click", function () {
                    triggerFileInputClick(inputId);
                });

            buttonContainer.append("input")
                .attr("type", "file")
                .attr("id", inputId)
                .attr("class", "hidden")
                .on("change", function () {
                    if (inputId === "datasetFileInput") {
                        handledatasetFileSelect(event); // Pass the event parameter here
                    } else if (inputId === "dataset_linksFileInput") {
                        handledataset_linksFileSelect(event); // Pass the event parameter here
                    }
                });
        }

        async function loadXLSXData() {
            // Create file input buttons using D3
            createFileInputButton("datasetButton", "datasetFileInput", "Load dataset");
            createFileInputButton("dataset_linksButton", "dataset_linksFileInput", "Load dataset_links");

            await waitForArrays();
        }

        function logEvent() {
            // console.log("Event");
            // console.log("dataset:", dataset);
            // console.log("dataset_links:", dataset_links);
        }

        function waitForArrays() {
            return new Promise((resolve) => {
                // Function to check if both arrays have data
                function checkArrays() {
                    if (dataset.length > 0 && dataset_links.length > 0) {
                        resolve(); // Resolve the promise when both arrays have data
                    } else {
                        setTimeout(checkArrays, 100); // Check again after a certain delay
                    }
                }

                checkArrays(); // Start checking the arrays
            });
        }

        //  //  //  //  //  //  //  //
        ///  CODE TO GET THINGS DONE:


        async function main() {

            console.log("in the main function");
    
            // Check if dataset and dataset_links already have data (are hardcoded)
            if (dataset.length > 0 && dataset_links.length > 0) {
                console.log("Using hardcoded dataset and dataset_links");
                button_width = calculateMaxButtonWidth();
                // Skip loading data files, directly update groups and display
                update_groups();
                setCircleArrangement();
                runFigure();
            } else {
                // No hardcoded data, proceed with loading data files
                console.log("No hardcoded data found. Loading data from files...");
                await loadXLSXData();  // Load data before drawing anything
                button_width = calculateMaxButtonWidth();
                logEvent();  // Log to help track program flow
                update_groups();
                setCircleArrangement();
                runFigure();
            }
        }

        main();  // and here it is that we start!
    </script>
</body>

</html>